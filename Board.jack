class Board {
    field Matrix maze;
    field View view;
    field int playerX;
    field int playerY;
    field int playerDir;
    field PlayerMap playerMap;


    field int coinsCollected;
    field boolean inEnd;

    constructor Board new(Matrix aMaze, int startX, int startY){
        let maze = aMaze;
        let playerX = startX;
        let playerY = startY;
        let view = View.new();
        let playerMap = PlayerMap.new(maze, 47, 7);
        let playerDir = 1;
        let coinsCollected = 0;
        let inEnd = false;
        return this;
    }

    method void showMap() {
        do playerMap.display(maze, playerX, playerY, playerDir);
        return;
    }
    
    //Moves the player by (x,y) blocks
    //x and y cannot be outside the range [-1,1]
    method void movePlayer(int dx, int dy) {
        var int newPosX;
        var int newPosY;
        if (playerDir = 0) {
            let newPosX = playerX + dx;
            let newPosY = playerY + dy;
        }
        if (playerDir = 1) {
            let newPosX = playerX + dy;
            let newPosY = playerY - dx;
        }
        if (playerDir = 2) {
            let newPosX = playerX - dx;
            let newPosY = playerY - dy;
        }
        if (playerDir = 3) {
            let newPosX = playerX - dy;
            let newPosY = playerY + dx;
        }

        if ((newPosX < 0) | (newPosX > (maze.getWidth() - 1)) | 
            (newPosY < 0) | (newPosY > (maze.getHeight() - 1)) |
            (maze.getInt(newPosX,newPosY) = 1)) {
            return;
        }
        if (maze.getInt(newPosX,newPosY) = 4) {
            let coinsCollected = coinsCollected + 1;
            do maze.setInt(newPosX,newPosY,0);
        }
        if (maze.getInt(newPosX,newPosY) = 3) {
            let inEnd = true;
        }
        
        let playerX = newPosX;
        let playerY = newPosY;
        return;
    }
    
    //Rotates the player
    //0 = facing down
    //1 = facing right
    //2 = facing up
    //3 = facing left
    method void rotatePlayer(boolean direction) {
        var int value;
        if (direction) {
            let playerDir = playerDir + 1;
            if (playerDir > 3) {
                let playerDir = 0;
            }
        }
        else {
            let playerDir = playerDir - 1;
            if (playerDir < 0) {
                let playerDir = 3;
            }
        }
        return;
    }

    method void updateView() {
        var Matrix viewMatrix;
        var int y;
        var int value;
        let viewMatrix = Matrix.new(3,6);
        let y = 0;
        while (y < 6) {
            let value = getViewSquare(0, y);
            do viewMatrix.setInt(0,y,value);
            
            //Mirroring left and right... still not sure why
            let value = getViewSquare(-1, y);
            do viewMatrix.setInt(2,y,value);

            let value = getViewSquare(1, y);
            do viewMatrix.setInt(1,y,value);
            
            let y = y + 1;
        }
        do view.setView(viewMatrix);
        do view.drawView();
        do updateMap();
        // attempt to visit area
        return;
    }

    method void updateMap() {
        var int delta, delta2;
        let delta = 1;
        if (playerDir = 0) { 
            while ((delta < 5) & ((playerY + delta) < maze.getHeight()) & ~(maze.getInt(playerX, playerY + delta) = 1)) {
                let delta = delta + 1;
            }
            let delta2 = Math.max(delta - 1, 1);
            do playerMap.visitArea(playerX - 1, playerY, 1, delta2, 1);
            do playerMap.visitArea(playerX, playerY, 1, delta, 2);
            do playerMap.visitArea(playerX + 1, playerY, 1, delta2, 1);
        }
        if (playerDir = 1) {
            while ((delta < 5) & ((playerX + delta) < maze.getWidth()) & ~(maze.getInt(playerX + delta, playerY) = 1)) {
                let delta = delta + 1;
            }
            let delta2 = Math.max(delta - 1, 1);
            do playerMap.visitArea(playerX, playerY - 1, delta2, 1, 1);
            do playerMap.visitArea(playerX, playerY, delta, 1, 2);
            do playerMap.visitArea(playerX, playerY + 1, delta2, 1, 1);
        }
        if (playerDir = 2) {
            while ((delta < 5) & (~((playerY - delta) < 0)) & ~(maze.getInt(playerX, (playerY - delta)) = 1)) {
                let delta = delta + 1;
            }
            let delta2 = Math.max(delta - 1, 1);
            do playerMap.visitArea(playerX - 1 , playerY - delta2 , 1, delta2, 1);
            do playerMap.visitArea(playerX, playerY - delta, 1, delta, 2);
            do playerMap.visitArea(playerX + 1, playerY - delta2, 1, delta2, 1);
        }
        if (playerDir = 3) {
            while ((delta < 5) & ~((playerX - delta) < 0) & ~(maze.getInt(playerX - delta, playerY) = 1)) {
                let delta = delta + 1;
            }
            let delta2 = Math.max(delta - 1, 1);
            do playerMap.visitArea(playerX - delta2, playerY - 1, delta2, 1, 1);
            do playerMap.visitArea(playerX - delta, playerY, delta, 1, 2);
            do playerMap.visitArea(playerX - delta2, playerY + 1, delta2, 1, 1);
        }
        return;

    }

    method int getViewSquare(int x, int y) {
        var int newX;
        var int newY;
        var int mazeW;
        var int mazeH;
        var int value;

        if (playerDir = 0) {
            let newX = playerX + x;
            let newY = playerY + y;
        }
        if (playerDir = 1) {
            let newX = playerX + y;
            let newY = playerY - x;
        }
        if (playerDir = 2) {
            let newX = playerX - x;
            let newY = playerY - y;
        }
        if (playerDir = 3) {
            let newX = playerX - y;
            let newY = playerY + x;
        }

        let mazeW = maze.getWidth();
        let mazeH = maze.getHeight();
        if ((newX < 0) | (newX > (mazeW - 1)) | (newY < 0) | (newY > (mazeH - 1))) {
            return 1;
        }
        return maze.getInt(newX,newY);
    }

    method int getCoins() {
        return coinsCollected;
    }

    method boolean isInEnd() {
        return inEnd;
    }

    method void dispose() {
        do maze.dispose();
        do view.dispose();
        do playerMap.dispose();
        do Memory.deAlloc(this);
        return;
    }
}